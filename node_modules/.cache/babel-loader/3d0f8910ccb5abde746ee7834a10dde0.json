{"ast":null,"code":"import React from 'react';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\n\nfunction Pattern(_ref) {\n  var id = _ref.id,\n      width = _ref.width,\n      height = _ref.height,\n      children = _ref.children;\n  return React.createElement('defs', null, React.createElement('pattern', {\n    id: id,\n    width: width,\n    height: height,\n    patternUnits: 'userSpaceOnUse'\n  }, children));\n}\n\nPattern.propTypes = {\n  id: PropTypes.string.isRequired,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]).isRequired\n};\nvar Orientation = {\n  horizontal: 'horizontal',\n  vertical: 'vertical',\n  diagonal: 'diagonal'\n};\n\nfunction pathForOrientation(_ref) {\n  var height = _ref.height,\n      orientation = _ref.orientation;\n  var path = void 0;\n\n  switch (orientation) {\n    case Orientation.vertical:\n      path = 'M ' + height / 2 + ', 0 l 0, ' + height;\n      break;\n\n    case Orientation.horizontal:\n      path = 'M 0,' + height / 2 + ' l ' + height + ',0';\n      break;\n\n    case Orientation.diagonal:\n      path = 'M 0,' + height + ' l ' + height + ',' + -height + ' M ' + -height / 4 + ',' + height / 4 + ' l ' + height / 2 + ',' + -height / 2 + '\\n             M ' + 3 / 4 * height + ',' + 5 / 4 * height + ' l ' + height / 2 + ',' + -height / 2;\n      break;\n\n    default:\n      path = 'M ' + height / 2 + ', 0 l 0, ' + height;\n  }\n\n  return path;\n}\n\nfunction PatternLines(_ref2) {\n  var id = _ref2.id,\n      width = _ref2.width,\n      height = _ref2.height,\n      stroke = _ref2.stroke,\n      strokeWidth = _ref2.strokeWidth,\n      strokeDasharray = _ref2.strokeDasharray,\n      _ref2$strokeLinecap = _ref2.strokeLinecap,\n      strokeLinecap = _ref2$strokeLinecap === undefined ? 'square' : _ref2$strokeLinecap,\n      _ref2$shapeRendering = _ref2.shapeRendering,\n      shapeRendering = _ref2$shapeRendering === undefined ? 'auto' : _ref2$shapeRendering,\n      _ref2$orientation = _ref2.orientation,\n      orientation = _ref2$orientation === undefined ? ['vertical'] : _ref2$orientation,\n      background = _ref2.background,\n      className = _ref2.className;\n  if (!Array.isArray(orientation)) orientation = [orientation];\n  return React.createElement(Pattern, {\n    id: id,\n    width: width,\n    height: height\n  }, !!background && React.createElement('rect', {\n    className: cx('vx-pattern-line-background'),\n    width: width,\n    height: height,\n    fill: background\n  }), orientation.map(function (o, i) {\n    return React.createElement('path', {\n      key: 'vx-' + id + '-line-' + o + '-' + i,\n      className: cx('vx-pattern-line', className),\n      d: pathForOrientation({\n        orientation: o,\n        height: height\n      }),\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray,\n      strokeLinecap: strokeLinecap,\n      shapeRendering: shapeRendering\n    });\n  }));\n}\n\nPatternLines.propTypes = {\n  id: PropTypes.string.isRequired,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  background: PropTypes.string,\n  stroke: PropTypes.string.isRequired,\n  strokeWidth: PropTypes.number.isRequired,\n  strokeDasharray: PropTypes.string,\n  className: PropTypes.string,\n  strokeLinecap: PropTypes.string,\n  shapeRendering: PropTypes.string,\n  orientation: PropTypes.array\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n/**\r\n * Creates an array of cirlces for a list of corners\r\n * in the format [[cornerX, cornerY], ...]\r\n */\n\n\nfunction createCircles(_ref) {\n  var corners = _ref.corners,\n      id = _ref.id,\n      radius = _ref.radius,\n      fill = _ref.fill,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      className = _ref.className;\n  return corners.map(function (_ref2) {\n    var _ref3 = slicedToArray(_ref2, 2),\n        cornerX = _ref3[0],\n        cornerY = _ref3[1];\n\n    return React.createElement('circle', {\n      key: id + '-complement-' + cornerX + '-' + cornerY,\n      className: cx('vx-pattern-circle vx-pattern-circle-complement', className),\n      cx: cornerX,\n      cy: cornerY,\n      r: radius,\n      fill: fill,\n      stroke: stroke,\n      strokeWidth: strokeWidth,\n      strokeDasharray: strokeDasharray\n    });\n  });\n}\n\nPatternCircles.propTypes = {\n  id: PropTypes.string.isRequired,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  radius: PropTypes.number,\n  fill: PropTypes.string,\n  className: PropTypes.string,\n  stroke: PropTypes.string,\n  strokeWidth: PropTypes.number,\n  strokeDasharray: PropTypes.string,\n  complement: PropTypes.bool,\n  background: PropTypes.string\n};\n\nfunction PatternCircles(_ref4) {\n  var id = _ref4.id,\n      width = _ref4.width,\n      height = _ref4.height,\n      _ref4$radius = _ref4.radius,\n      radius = _ref4$radius === undefined ? 2 : _ref4$radius,\n      fill = _ref4.fill,\n      stroke = _ref4.stroke,\n      strokeWidth = _ref4.strokeWidth,\n      strokeDasharray = _ref4.strokeDasharray,\n      background = _ref4.background,\n      _ref4$complement = _ref4.complement,\n      complement = _ref4$complement === undefined ? false : _ref4$complement,\n      className = _ref4.className;\n  var corners = void 0;\n\n  if (complement) {\n    corners = [[0, 0], [0, height], [width, 0], [width, height]];\n  }\n\n  return React.createElement(Pattern, {\n    id: id,\n    width: width,\n    height: height\n  }, !!background && React.createElement('rect', {\n    width: width,\n    height: height,\n    fill: background\n  }), React.createElement('circle', {\n    className: cx('vx-pattern-circle', className),\n    cx: width / 2,\n    cy: height / 2,\n    r: radius,\n    fill: fill,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray\n  }), complement && createCircles({\n    corners: corners,\n    id: id,\n    radius: radius,\n    fill: fill,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray\n  }));\n}\n\nfunction PatternPath(_ref) {\n  var id = _ref.id,\n      width = _ref.width,\n      height = _ref.height,\n      path = _ref.path,\n      _ref$fill = _ref.fill,\n      fill = _ref$fill === undefined ? 'transparent' : _ref$fill,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      _ref$strokeLinecap = _ref.strokeLinecap,\n      strokeLinecap = _ref$strokeLinecap === undefined ? 'square' : _ref$strokeLinecap,\n      _ref$shapeRendering = _ref.shapeRendering,\n      shapeRendering = _ref$shapeRendering === undefined ? 'auto' : _ref$shapeRendering,\n      background = _ref.background,\n      className = _ref.className;\n  return React.createElement(Pattern, {\n    id: id,\n    width: width,\n    height: height\n  }, !!background && React.createElement('rect', {\n    width: width,\n    height: height,\n    fill: background\n  }), React.createElement('path', {\n    className: cx('vx-pattern-path', className),\n    d: path,\n    fill: fill,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    strokeLinecap: strokeLinecap,\n    shapeRendering: shapeRendering\n  }));\n}\n\nPatternPath.propTypes = {\n  id: PropTypes.string.isRequired,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  path: PropTypes.string,\n  fill: PropTypes.string,\n  className: PropTypes.string,\n  background: PropTypes.string,\n  stroke: PropTypes.string,\n  strokeWidth: PropTypes.number,\n  strokeDasharray: PropTypes.string,\n  strokeLinecap: PropTypes.string,\n  shapeRendering: PropTypes.string\n};\n\nfunction PatternWaves(_ref) {\n  var id = _ref.id,\n      width = _ref.width,\n      height = _ref.height,\n      fill = _ref.fill,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      strokeLinecap = _ref.strokeLinecap,\n      shapeRendering = _ref.shapeRendering,\n      background = _ref.background,\n      className = _ref.className;\n  return React.createElement(PatternPath, {\n    className: cx('vx-pattern-wave', className),\n    path: 'M 0 ' + height / 2 + ' c ' + height / 8 + ' ' + -height / 4 + ' , ' + height * 3 / 8 + ' ' + -height / 4 + ' , ' + height / 2 + ' 0\\n             c ' + height / 8 + ' ' + height / 4 + ' , ' + height * 3 / 8 + ' ' + height / 4 + ' , ' + height / 2 + ' 0 M ' + -height / 2 + ' ' + height / 2 + '\\n             c ' + height / 8 + ' ' + height / 4 + ' , ' + height * 3 / 8 + ' ' + height / 4 + ' , ' + height / 2 + ' 0 M ' + height + ' ' + height / 2 + '\\n             c ' + height / 8 + ' ' + -height / 4 + ' , ' + height * 3 / 8 + ' ' + -height / 4 + ' , ' + height / 2 + ' 0',\n    id: id,\n    width: width,\n    height: height,\n    fill: fill,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    strokeLinecap: strokeLinecap,\n    shapeRendering: shapeRendering,\n    background: background\n  });\n}\n\nPatternWaves.propTypes = {\n  id: PropTypes.string.isRequired,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  fill: PropTypes.string,\n  className: PropTypes.string,\n  background: PropTypes.string,\n  stroke: PropTypes.string,\n  strokeWidth: PropTypes.number,\n  strokeDasharray: PropTypes.string,\n  strokeLinecap: PropTypes.string,\n  shapeRendering: PropTypes.string\n};\nPatternHexagons.propTypes = {\n  id: PropTypes.string.isRequired,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  size: PropTypes.number,\n  fill: PropTypes.string,\n  className: PropTypes.string,\n  background: PropTypes.string,\n  stroke: PropTypes.string,\n  strokeWidth: PropTypes.number,\n  strokeDasharray: PropTypes.string,\n  strokeLinecap: PropTypes.string,\n  shapeRendering: PropTypes.string\n};\n\nfunction PatternHexagons(_ref) {\n  var id = _ref.id,\n      width = _ref.width,\n      height = _ref.height,\n      fill = _ref.fill,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      strokeLinecap = _ref.strokeLinecap,\n      shapeRendering = _ref.shapeRendering,\n      background = _ref.background,\n      className = _ref.className,\n      _ref$size = _ref.size,\n      size = _ref$size === undefined ? 3 : _ref$size;\n  var s = Math.sqrt(size);\n  return React.createElement(PatternPath, {\n    className: cx('vx-pattern-hexagon', className),\n    path: 'M ' + height + ',0 l ' + height + ',0 l ' + height / 2 + ',' + height * s / 2 + ' l ' + -height / 2 + ',' + height * s / 2 + ' l ' + -height + ',0 l ' + -height / 2 + ',' + -height * s / 2 + ' Z M 0,' + height * s / 2 + ' l ' + height / 2 + ',0 M ' + 3 * height + ',' + height * s / 2 + ' l ' + -height / 2 + ',0',\n    id: id,\n    width: size,\n    height: s,\n    fill: fill,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    strokeLinecap: strokeLinecap,\n    shapeRendering: shapeRendering,\n    background: background\n  });\n}\n\nexport { Pattern, PatternLines, PatternCircles, PatternWaves, PatternHexagons, PatternPath, Orientation as PatternOrientation };","map":null,"metadata":{},"sourceType":"module"}