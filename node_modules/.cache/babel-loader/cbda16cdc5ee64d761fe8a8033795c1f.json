{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n/* eslint no-param-reassign: 0 */\n\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { extent, max } from 'd3-array';\nimport { chartTheme } from '@data-ui/theme';\nimport { AreaClosed, LinePath } from '@vx/shape';\nimport { curveBasis } from '@vx/curve';\nimport { Group } from '@vx/group';\nimport { scaleLinear } from '@vx/scale';\nimport AnimatedDensitySeries from './animated/AnimatedDensitySeries';\nimport { binnedDataShape } from '../utils/propShapes';\nimport kernelDensityEstimator from '../utils/kernelDensityEstimator';\nimport kernelParabolic from '../utils/kernels/epanechnikov';\nimport kernelGaussian from '../utils/kernels/gaussian';\nvar propTypes = {\n  animated: PropTypes.bool,\n  rawData: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string])),\n  binnedData: binnedDataShape,\n  binType: PropTypes.oneOf(['numeric', 'categorical']),\n  fill: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  fillOpacity: PropTypes.oneOfType([PropTypes.func, PropTypes.number]),\n  horizontal: PropTypes.bool,\n  kernel: PropTypes.oneOf(['gaussian', 'parabolic']),\n  showArea: PropTypes.bool,\n  showLine: PropTypes.bool,\n  smoothing: PropTypes.number,\n  stroke: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  strokeDasharray: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  strokeLinecap: PropTypes.oneOf(['butt', 'square', 'round', 'inherit']),\n  strokeWidth: PropTypes.oneOfType([PropTypes.func, PropTypes.number]),\n  useEntireScale: PropTypes.bool,\n  valueAccessor: PropTypes.func,\n  valueKey: PropTypes.string,\n  // likely injected by parent Histogram\n  binScale: PropTypes.func,\n  valueScale: PropTypes.func\n};\nvar defaultProps = {\n  animated: true,\n  rawData: [],\n  binnedData: [],\n  binScale: null,\n  binType: null,\n  fill: chartTheme.colors.default,\n  fillOpacity: 0.3,\n  horizontal: false,\n  kernel: 'gaussian',\n  showArea: true,\n  showLine: true,\n  smoothing: 1,\n  stroke: chartTheme.colors.default,\n  strokeWidth: 2,\n  strokeDasharray: null,\n  strokeLinecap: 'round',\n  useEntireScale: false,\n  valueAccessor: function valueAccessor(d) {\n    return d;\n  },\n  valueKey: 'count',\n  valueScale: null\n};\nvar BIN_OFFSET = 0.5;\n\nvar getBin = function getBin(d) {\n  return typeof d.bin === 'undefined' ? d.bin0 : d.bin;\n};\n\nvar densityAccessor = function densityAccessor(d) {\n  return d.value;\n};\n\nvar cumulativeAccessor = function cumulativeAccessor(d) {\n  return d.cumulative;\n};\n\nfunction DensitySeries(_ref) {\n  var animated = _ref.animated,\n      rawData = _ref.rawData,\n      binnedData = _ref.binnedData,\n      binScale = _ref.binScale,\n      binType = _ref.binType,\n      fill = _ref.fill,\n      fillOpacity = _ref.fillOpacity,\n      horizontal = _ref.horizontal,\n      kernel = _ref.kernel,\n      showArea = _ref.showArea,\n      showLine = _ref.showLine,\n      smoothing = _ref.smoothing,\n      stroke = _ref.stroke,\n      strokeWidth = _ref.strokeWidth,\n      strokeDasharray = _ref.strokeDasharray,\n      strokeLinecap = _ref.strokeLinecap,\n      useEntireScale = _ref.useEntireScale,\n      valueAccessor = _ref.valueAccessor,\n      valueKey = _ref.valueKey,\n      valueScale = _ref.valueScale;\n  if (!showArea && !showLine) return null;\n  var binWidth = binScale.bandwidth ? binScale.bandwidth() // categorical\n  : Math.abs(binScale(binnedData[0].bin1) - binScale(binnedData[0].bin0)); // numeric\n\n  var binOffset = BIN_OFFSET * binWidth * (horizontal && binType === 'numeric' ? -1 : 1); // all density estimators require numeric data, so if we're passed categorical data\n  // or pre-aggregated data, we just draw an area curve using the binned data\n\n  var densityScale = valueScale;\n\n  var getDensity = function getDensity(d) {\n    return d[valueKey];\n  };\n\n  var densityData = binnedData;\n\n  if (binType === 'numeric' && rawData.length > 0) {\n    // @TODO cache this with a non-functional component\n    var cumulative = /cumulative/gi.test(valueKey);\n    var bins = binnedData.map(getBin);\n    var kernelFunc = kernel === 'gaussian' ? kernelGaussian() : kernelParabolic(smoothing);\n    var estimator = kernelDensityEstimator(kernelFunc, bins);\n    densityData = estimator(rawData.map(valueAccessor)); // area fills become inverted when the last value is less than the first value.\n    // padding with 0s ensures this never happens\n\n    densityData.unshift(_extends({}, densityData[0], {\n      value: 0\n    }));\n    densityData.push(_extends({}, densityData[densityData.length - 1], {\n      value: 0\n    }));\n    var densityRange = valueScale.range();\n\n    if (!useEntireScale) {\n      // set the range of the density scale to match the maximum data value\n      var maxVal = max(binnedData, function (d) {\n        return d[valueKey];\n      });\n      densityRange[1] = valueScale(maxVal);\n    }\n\n    densityScale = scaleLinear({\n      domain: extent(densityData, function (d, i) {\n        var val = densityAccessor(d); // compute cumulative in this loop\n\n        d.cumulative = val + (i > 0 ? densityData[i - 1].cumulative : 0);\n        d.id = i;\n        return cumulative ? d.cumulative : val;\n      }),\n      range: densityRange\n    });\n    getDensity = cumulative ? cumulativeAccessor : densityAccessor;\n  }\n\n  var offSetBinScale = binScale.copy();\n  offSetBinScale.range(binScale.range().map(function (v) {\n    return v + binOffset;\n  }));\n  var getX = horizontal ? getDensity : getBin;\n  var getY = horizontal ? getBin : getDensity;\n  var xScale = horizontal ? densityScale : offSetBinScale;\n  var yScale = horizontal ? offSetBinScale : densityScale;\n  return React.createElement(Group, {\n    style: {\n      pointerEvents: 'none'\n    }\n  }, animated && React.createElement(AnimatedDensitySeries, {\n    densityData: densityData,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    horizontal: horizontal,\n    getX: getX,\n    getY: getY,\n    showArea: showArea,\n    showLine: showLine,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    strokeLinecap: strokeLinecap,\n    xScale: xScale,\n    yScale: yScale\n  }), !animated && showArea && React.createElement(AreaClosed, {\n    data: densityData,\n    x: getX,\n    y: getY,\n    xScale: xScale,\n    yScale: yScale,\n    fill: fill,\n    fillOpacity: fillOpacity,\n    stroke: \"transparent\",\n    strokeWidth: strokeWidth,\n    curve: curveBasis\n  }), !animated && showLine && strokeWidth > 0 && React.createElement(LinePath, {\n    data: densityData,\n    x: getX,\n    y: getY,\n    xScale: xScale,\n    yScale: yScale,\n    stroke: stroke,\n    strokeWidth: strokeWidth,\n    strokeDasharray: strokeDasharray,\n    strokeLinecap: strokeLinecap,\n    curve: curveBasis,\n    glyph: null\n  }));\n}\n\nDensitySeries.propTypes = propTypes;\nDensitySeries.defaultProps = defaultProps;\nDensitySeries.displayName = 'DensitySeries';\nexport default DensitySeries;","map":null,"metadata":{},"sourceType":"module"}