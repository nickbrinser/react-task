{"ast":null,"code":"import { max as d3Max } from 'd3-array';\nimport caseInsensitiveSort from './caseInsensitiveSort';\n/*\n * Computes the bin and value domains from numeric or categorical bins\n */\n\nexport default function computeDomainsFromBins(_ref) {\n  var binsByIndex = _ref.binsByIndex,\n      binType = _ref.binType,\n      valueKey = _ref.valueKey,\n      binValues = _ref.binValues;\n  var binDomain;\n  var valueDomain;\n  Object.values(binsByIndex).forEach(function (bins) {\n    var currValueMax = d3Max(bins, function (d) {\n      return d[valueKey];\n    });\n\n    if (valueDomain) {\n      valueDomain[1] = Math.max(currValueMax, valueDomain[1]);\n    } else {\n      valueDomain = [0, currValueMax];\n    }\n\n    if (binType === 'numeric') {\n      if (binDomain) {\n        binDomain[0] = Math.min(bins[0].bin0, binDomain[0]);\n        binDomain[1] = Math.max(bins[bins.length - 1].bin1, binDomain[1]);\n      } else {\n        binDomain = [bins[0].bin0, bins[bins.length - 1].bin1];\n      }\n    } else {\n      if (!binDomain) binDomain = {}; // use lookup to avoid lots of Array scans\n\n      bins.forEach(function (bin) {\n        binDomain[bin.bin] = true;\n      });\n    }\n  });\n\n  if (Array.isArray(binValues)) {\n    var providedBinsCoverDomain = true;\n    binValues.forEach(function (binValue) {\n      if (!(binValue in binDomain)) {\n        providedBinsCoverDomain = false;\n      }\n    });\n\n    if (providedBinsCoverDomain) {\n      binDomain = binValues;\n    }\n  }\n\n  if (!Array.isArray(binDomain)) {\n    binDomain = Object.keys(binDomain).sort(caseInsensitiveSort);\n  }\n\n  return {\n    binDomain: binDomain,\n    valueDomain: valueDomain\n  };\n}","map":null,"metadata":{},"sourceType":"module"}