{"ast":null,"code":"import { histogram as d3Histogram, extent as d3Extent } from 'd3-array';\nimport { scaleLinear } from 'd3-scale';\nvar DEFAULT_BIN_COUNT = 10;\n/*\n * handles binning of numeric data by series index\n * if binValues are passed, ignores other bin values that are encountered\n *\n * returns an object of bins keyed on series index with the following shape\n * {\n *   [seriesIdx]: Array<Object{\n *      bin0: String,\n *      bin1: String,\n *      data: Array<datum>,\n *      count: Number,\n *      id: String,\n *    }>,\n * }\n */\n\nexport default function binNumericData(_ref) {\n  var allData = _ref.allData,\n      _ref$binCount = _ref.binCount,\n      userBinCount = _ref$binCount === void 0 ? DEFAULT_BIN_COUNT : _ref$binCount,\n      binValues = _ref.binValues,\n      limits = _ref.limits,\n      rawDataByIndex = _ref.rawDataByIndex,\n      valueAccessor = _ref.valueAccessor;\n  var binCount = Array.isArray(binValues) ? binValues.length : userBinCount;\n  var binsByIndex = {};\n  var histogram = d3Histogram();\n  var extent = d3Extent(allData, valueAccessor);\n\n  if (binValues) {\n    // account for extent of binValues if passed\n    var binExtent = d3Extent(binValues);\n    extent = [Math.min(binExtent[0], extent[0]), Math.max(binExtent[1], extent[1])];\n  }\n\n  var scale = scaleLinear().domain(extent).nice(binCount);\n  histogram.domain(limits || scale.domain()).thresholds(binValues || scale.ticks(binCount));\n  Object.keys(rawDataByIndex).forEach(function (index) {\n    var data = rawDataByIndex[index];\n    var seriesBins = histogram.value(valueAccessor)(data); // if the last bin equals the upper bound of the second to last bin, combine them\n    // see https://github.com/d3/d3-array/issues/46#issuecomment-269873644\n\n    var lastBinIndex = seriesBins.length - 1;\n    var lastBin = seriesBins[lastBinIndex];\n    var nextToLastBin = seriesBins[lastBinIndex - 1];\n    var shouldCombineEndBins = nextToLastBin && nextToLastBin.x1 === lastBin.x0 && lastBin.x1 === lastBin.x0;\n    var filteredBins = shouldCombineEndBins ? seriesBins.slice(0, -1) : seriesBins;\n    binsByIndex[index] = filteredBins.map(function (bin, i) {\n      return {\n        bin0: bin.x0,\n        // if the upper limit equals the lower one, use the delta between this bin and the last\n        bin1: bin.x0 === bin.x1 ? i > 0 && bin.x0 + bin.x0 - seriesBins[i - 1].x0 || bin.x1 + 1 : bin.x1,\n        data: [].concat(bin).concat(shouldCombineEndBins && (shouldCombineEndBins && i === lastBinIndex - 1 ? lastBin : [])),\n        // if the last bin was inclusive / omitted, add its count to the last bin\n        count: bin.length + (shouldCombineEndBins && i === lastBinIndex - 1 ? lastBin.length || 0 : 0),\n        id: i.toString()\n      };\n    });\n  });\n  return binsByIndex;\n}","map":null,"metadata":{},"sourceType":"module"}